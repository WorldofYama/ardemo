
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR.js Hiro Marker Demo (Edge + GitHub Pages)</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>

  <!-- three.js（UMD版。例: r128）-->
  ./libs/three.min.js</script>

  <!-- AR.js（three.js版ビルド：THREEx.* を含む）-->
  ./libs/ar.js</script>
</head>
<body>
<script>
  // ===== Three.js 基本セットアップ =====
  const scene = new THREE.Scene();
  const camera = new THREE.Camera();
  scene.add(camera);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setClearColor(0x000000, 0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.position = 'absolute';
  renderer.domElement.style.top = '0';
  renderer.domElement.style.left = '0';
  document.body.appendChild(renderer.domElement);

  // ===== AR.js ソース（Webカメラ） =====
  const arSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });

  function onResize() {
    arSource.onResizeElement();
    arSource.copyElementSizeTo(renderer.domElement);
    if (arContext && arContext.arController) {
      arSource.copyElementSizeTo(arContext.arController.canvas);
    }
  }

  arSource.init(() => onResize());
  window.addEventListener('resize', onResize);

  // ===== AR.js コンテキスト =====
  const arContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: './libs/data/camera_para.dat',
    detectionMode: 'mono'
  });

  arContext.init(() => {
    // Three.js カメラに投影行列を適用
    camera.projectionMatrix.copy(arContext.getProjectionMatrix());
  });

  // ===== マーカー（hiro） =====
  const markerRoot = new THREE.Group();
  scene.add(markerRoot);

  const markerControls = new THREEx.ArMarkerControls(arContext, markerRoot, {
    type: 'pattern',
    patternUrl: './assets/patt.hiro' // 相対パスで確実に
  });

  // ===== 表示オブジェクト（三角錐） =====
  const geometry = new THREE.ConeGeometry(0.5, 1, 4); // 半径0.5, 高さ1, 4角錐
  const material = new THREE.MeshNormalMaterial();
  const cone = new THREE.Mesh(geometry, material);
  cone.position.y = 0.5; // マーカー面から少し上げる
  markerRoot.add(cone);

  // ===== レンダリングループ =====
  (function animate(){
    requestAnimationFrame(animate);
    if (arSource.ready) arContext.update(arSource.domElement);
    cone.rotation.y += 0.01;
    renderer.render(scene, camera);
  })();
</script>
</body>
</html>

